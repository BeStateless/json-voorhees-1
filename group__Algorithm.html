<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JSON Voorhees: Algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://www.mathjax.org/mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">JSON Voorhees
   </div>
   <div id="projectbrief">Killer JSON for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Algorithm.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithm</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of useful free functions a la <code></code> &lt;algorithm&gt;.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsonv_1_1compare__traits.html">jsonv::compare_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits describing how to perform various aspects of comparison.  <a href="structjsonv_1_1compare__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structjsonv_1_1diff__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#structjsonv_1_1diff__result">jsonv::diff_result</a></td></tr>
<tr class="memdesc:structjsonv_1_1diff__result"><td class="mdescLeft">&#160;</td><td class="mdescRight">The results of the <code>diff</code> operation.  <a href="group__Algorithm.html#structjsonv_1_1diff__result">More...</a><br /></td></tr>
<tr class="separator:structjsonv_1_1diff__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsonv_1_1merge__rules.html">jsonv::merge_rules</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used in <code>merge_explicit</code> for defining what the function should do in the cases of conflicts.  <a href="classjsonv_1_1merge__rules.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsonv_1_1dynamic__merge__rules.html">jsonv::dynamic_merge_rules</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <code><a class="el" href="classjsonv_1_1merge__rules.html" title="This class is used in merge_explicit for defining what the function should do in the cases of conflic...">merge_rules</a></code> that allows you to bind whatever functions you want to resolve conflicts.  <a href="classjsonv_1_1dynamic__merge__rules.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsonv_1_1throwing__merge__rules.html">jsonv::throwing_merge_rules</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These rules throw an exception on all conflicts.  <a href="classjsonv_1_1throwing__merge__rules.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsonv_1_1recursive__merge__rules.html">jsonv::recursive_merge_rules</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These rules will recursively merge everything they can and coerce all values.  <a href="classjsonv_1_1recursive__merge__rules.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsonv_1_1validation__error.html">jsonv::validation_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error thrown when an unrepresentable value is encountered in a JSON AST.  <a href="classjsonv_1_1validation__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsonv_1_1value__compare.html">jsonv::value_compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <code>value</code> to another using the standard-issue <code><a class="el" href="classjsonv_1_1value.html#a50a89be9c59fdad1d3bed40610e1750d" title="Used to build a strict-ordering of JSON values. ">value::compare</a></code> function.  <a href="structjsonv_1_1value__compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsonv_1_1value__compare__icase.html">jsonv::value_compare_icase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values, ignoring the case for any <code>value</code> with <code>kind::string</code>.  <a href="structjsonv_1_1value__compare__icase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">jsonv::basic_value_binary_predicate&lt; FCompare, FResult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9ca58023877a35cf4d1e88a63d63761f"><td class="memItemLeft" align="right" valign="top"><a id="ga9ca58023877a35cf4d1e88a63d63761f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_equal_to</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare.html">value_compare</a>, std::equal_to&lt; int &gt; &gt;</td></tr>
<tr class="separator:ga9ca58023877a35cf4d1e88a63d63761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f8c22b40e00eee938957cb5c7cd5e66"><td class="memItemLeft" align="right" valign="top"><a id="ga2f8c22b40e00eee938957cb5c7cd5e66"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_equal_to_icase</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare__icase.html">value_compare_icase</a>, std::equal_to&lt; int &gt; &gt;</td></tr>
<tr class="separator:ga2f8c22b40e00eee938957cb5c7cd5e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab404d8e21e9b55b9c46bbb66365516f2"><td class="memItemLeft" align="right" valign="top"><a id="gab404d8e21e9b55b9c46bbb66365516f2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_not_equal_to</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare.html">value_compare</a>, std::not_equal_to&lt; int &gt; &gt;</td></tr>
<tr class="separator:gab404d8e21e9b55b9c46bbb66365516f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf686de8fd2b46c41deef54ce09b7a66"><td class="memItemLeft" align="right" valign="top"><a id="gabf686de8fd2b46c41deef54ce09b7a66"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_not_equal_to_icase</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare__icase.html">value_compare_icase</a>, std::not_equal_to&lt; int &gt; &gt;</td></tr>
<tr class="separator:gabf686de8fd2b46c41deef54ce09b7a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafd7bb77c3fb0837e20d5c653058f28b"><td class="memItemLeft" align="right" valign="top"><a id="gaafd7bb77c3fb0837e20d5c653058f28b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_less</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare.html">value_compare</a>, std::less&lt; int &gt; &gt;</td></tr>
<tr class="separator:gaafd7bb77c3fb0837e20d5c653058f28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae217e6c4cda2b52d14b86caa32ccdd19"><td class="memItemLeft" align="right" valign="top"><a id="gae217e6c4cda2b52d14b86caa32ccdd19"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_less_icase</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare__icase.html">value_compare_icase</a>, std::less&lt; int &gt; &gt;</td></tr>
<tr class="separator:gae217e6c4cda2b52d14b86caa32ccdd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0abaf89f0c4223fd3c25971b66e065f"><td class="memItemLeft" align="right" valign="top"><a id="gaa0abaf89f0c4223fd3c25971b66e065f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_less_equal</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare.html">value_compare</a>, std::less_equal&lt; int &gt; &gt;</td></tr>
<tr class="separator:gaa0abaf89f0c4223fd3c25971b66e065f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cb882aaa74ffc3c7395a8f8d52af1db"><td class="memItemLeft" align="right" valign="top"><a id="ga7cb882aaa74ffc3c7395a8f8d52af1db"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_less_equal_icase</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare__icase.html">value_compare_icase</a>, std::less_equal&lt; int &gt; &gt;</td></tr>
<tr class="separator:ga7cb882aaa74ffc3c7395a8f8d52af1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d86cd255fd5e1348ba7315aa165543"><td class="memItemLeft" align="right" valign="top"><a id="ga38d86cd255fd5e1348ba7315aa165543"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_greater</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare.html">value_compare</a>, std::greater&lt; int &gt; &gt;</td></tr>
<tr class="separator:ga38d86cd255fd5e1348ba7315aa165543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5691aa87934be753281398ecc97cf5aa"><td class="memItemLeft" align="right" valign="top"><a id="ga5691aa87934be753281398ecc97cf5aa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_greater_icase</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare__icase.html">value_compare_icase</a>, std::greater&lt; int &gt; &gt;</td></tr>
<tr class="separator:ga5691aa87934be753281398ecc97cf5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacd50fbfd594a11c6f7a7f18032cab52"><td class="memItemLeft" align="right" valign="top"><a id="gaacd50fbfd594a11c6f7a7f18032cab52"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_greater_equal</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare.html">value_compare</a>, std::greater_equal&lt; int &gt; &gt;</td></tr>
<tr class="separator:gaacd50fbfd594a11c6f7a7f18032cab52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad28117f3ce983bf2af140f08fd753d3c"><td class="memItemLeft" align="right" valign="top"><a id="gad28117f3ce983bf2af140f08fd753d3c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_greater_equal_icase</b> = <a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">basic_value_binary_predicate</a>&lt; <a class="el" href="structjsonv_1_1value__compare__icase.html">value_compare_icase</a>, std::greater_equal&lt; int &gt; &gt;</td></tr>
<tr class="separator:gad28117f3ce983bf2af140f08fd753d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga18053a6a38a0ddd3739a9b253e6f8301"><td class="memTemplParams" colspan="2">template&lt;typename TCompareTraits &gt; </td></tr>
<tr class="memitem:ga18053a6a38a0ddd3739a9b253e6f8301"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga18053a6a38a0ddd3739a9b253e6f8301">jsonv::compare</a> (const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;a, const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;b, const TCompareTraits &amp;traits)</td></tr>
<tr class="memdesc:ga18053a6a38a0ddd3739a9b253e6f8301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values <em>a</em> and <em>b</em> using the comparison <em>traits</em>.  <a href="group__Algorithm.html#ga18053a6a38a0ddd3739a9b253e6f8301">More...</a><br /></td></tr>
<tr class="separator:ga18053a6a38a0ddd3739a9b253e6f8301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae72c162e414d753ba60c1e84b49ff2ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#gae72c162e414d753ba60c1e84b49ff2ab">jsonv::compare</a> (const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;a, const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;b)</td></tr>
<tr class="memdesc:gae72c162e414d753ba60c1e84b49ff2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values <em>a</em> and <em>b</em> with strict comparison traits.  <a href="group__Algorithm.html#gae72c162e414d753ba60c1e84b49ff2ab">More...</a><br /></td></tr>
<tr class="separator:gae72c162e414d753ba60c1e84b49ff2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b55f49e5cab8746e5304c132ae1e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga74b55f49e5cab8746e5304c132ae1e87">jsonv::compare_icase</a> (const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;a, const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;b)</td></tr>
<tr class="memdesc:ga74b55f49e5cab8746e5304c132ae1e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values <em>a</em> and <em>b</em>, but use case-insensitive matching on <code>kind::string</code> values.  <a href="group__Algorithm.html#ga74b55f49e5cab8746e5304c132ae1e87">More...</a><br /></td></tr>
<tr class="separator:ga74b55f49e5cab8746e5304c132ae1e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2480514da0048b025804fd95635dbc79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> <a class="el" href="group__Algorithm.html#structjsonv_1_1diff__result">diff_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga2480514da0048b025804fd95635dbc79">jsonv::diff</a> (<a class="el" href="classjsonv_1_1value.html">value</a> left, <a class="el" href="classjsonv_1_1value.html">value</a> right)</td></tr>
<tr class="memdesc:ga2480514da0048b025804fd95635dbc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the differences and similarities between the structures of <em>left</em> and <em>right</em>.  <a href="group__Algorithm.html#ga2480514da0048b025804fd95635dbc79">More...</a><br /></td></tr>
<tr class="separator:ga2480514da0048b025804fd95635dbc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0abfde4a15bb3d727727d17e055d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> <a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga6f0abfde4a15bb3d727727d17e055d4d">jsonv::map</a> (const std::function&lt; <a class="el" href="classjsonv_1_1value.html">value</a>(const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;)&gt; &amp;func, const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;input)</td></tr>
<tr class="memdesc:ga6f0abfde4a15bb3d727727d17e055d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a function over the values in the <em>input</em>.  <a href="group__Algorithm.html#ga6f0abfde4a15bb3d727727d17e055d4d">More...</a><br /></td></tr>
<tr class="separator:ga6f0abfde4a15bb3d727727d17e055d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a92faf8b28a6ec0ea0360cdf475f43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> <a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga20a92faf8b28a6ec0ea0360cdf475f43">jsonv::map</a> (const std::function&lt; <a class="el" href="classjsonv_1_1value.html">value</a>(<a class="el" href="classjsonv_1_1value.html">value</a>)&gt; &amp;func, <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&amp;input)</td></tr>
<tr class="memdesc:ga20a92faf8b28a6ec0ea0360cdf475f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a function over the values in the <em>input</em>.  <a href="group__Algorithm.html#ga20a92faf8b28a6ec0ea0360cdf475f43">More...</a><br /></td></tr>
<tr class="separator:ga20a92faf8b28a6ec0ea0360cdf475f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74e9854143e94b2b014efe15eb63fdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#gaf74e9854143e94b2b014efe15eb63fdf">jsonv::traverse</a> (const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;tree, const std::function&lt; void(const <a class="el" href="classjsonv_1_1path.html">path</a> &amp;, const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;)&gt; &amp;func, const <a class="el" href="classjsonv_1_1path.html">path</a> &amp;base_path, bool leafs_only=false)</td></tr>
<tr class="memdesc:gaf74e9854143e94b2b014efe15eb63fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively walk the provided <em>tree</em> and call <em>func</em> for each item in the tree.  <a href="group__Algorithm.html#gaf74e9854143e94b2b014efe15eb63fdf">More...</a><br /></td></tr>
<tr class="separator:gaf74e9854143e94b2b014efe15eb63fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc870c7f69dc8731b6a97afa97df43cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#gacc870c7f69dc8731b6a97afa97df43cc">jsonv::traverse</a> (const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;tree, const std::function&lt; void(const <a class="el" href="classjsonv_1_1path.html">path</a> &amp;, const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;)&gt; &amp;func, bool leafs_only=false)</td></tr>
<tr class="memdesc:gacc870c7f69dc8731b6a97afa97df43cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively walk the provided <em>tree</em> and call <em>func</em> for each item in the tree.  <a href="group__Algorithm.html#gacc870c7f69dc8731b6a97afa97df43cc">More...</a><br /></td></tr>
<tr class="separator:gacc870c7f69dc8731b6a97afa97df43cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3d51f2832841e7c90ba1eb9b9b93a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> <a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga5f3d51f2832841e7c90ba1eb9b9b93a1">jsonv::merge_explicit</a> (const <a class="el" href="classjsonv_1_1merge__rules.html">merge_rules</a> &amp;rules, <a class="el" href="classjsonv_1_1path.html">path</a> current_path, <a class="el" href="classjsonv_1_1value.html">value</a> a, <a class="el" href="classjsonv_1_1value.html">value</a> b)</td></tr>
<tr class="memdesc:ga5f3d51f2832841e7c90ba1eb9b9b93a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two <code>values</code>, <em>a</em> and <em>b</em> into a single <code>value</code>.  <a href="group__Algorithm.html#ga5f3d51f2832841e7c90ba1eb9b9b93a1">More...</a><br /></td></tr>
<tr class="separator:ga5f3d51f2832841e7c90ba1eb9b9b93a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953ea8225a035f7dd1dbb88285f980d4"><td class="memItemLeft" align="right" valign="top"><a id="ga953ea8225a035f7dd1dbb88285f980d4"></a>
<a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> <a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::merge_explicit</b> (const <a class="el" href="classjsonv_1_1merge__rules.html">merge_rules</a> &amp;, const <a class="el" href="classjsonv_1_1path.html">path</a> &amp;, <a class="el" href="classjsonv_1_1value.html">value</a> a)</td></tr>
<tr class="separator:ga953ea8225a035f7dd1dbb88285f980d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f008513377f09e7d66e046bef67747"><td class="memItemLeft" align="right" valign="top"><a id="ga77f008513377f09e7d66e046bef67747"></a>
<a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> <a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::merge_explicit</b> (const <a class="el" href="classjsonv_1_1merge__rules.html">merge_rules</a> &amp;, const <a class="el" href="classjsonv_1_1path.html">path</a> &amp;)</td></tr>
<tr class="separator:ga77f008513377f09e7d66e046bef67747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe54f7378529e21de6fc78477313c291"><td class="memTemplParams" colspan="2"><a id="gabe54f7378529e21de6fc78477313c291"></a>
template&lt;typename... TValue&gt; </td></tr>
<tr class="memitem:gabe54f7378529e21de6fc78477313c291"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jsonv::merge_explicit</b> (const <a class="el" href="classjsonv_1_1merge__rules.html">merge_rules</a> &amp;rules, <a class="el" href="classjsonv_1_1path.html">path</a> current_path, <a class="el" href="classjsonv_1_1value.html">value</a> a, <a class="el" href="classjsonv_1_1value.html">value</a> b, <a class="el" href="classjsonv_1_1value.html">value</a> c, TValue &amp;&amp;... rest)</td></tr>
<tr class="separator:gabe54f7378529e21de6fc78477313c291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0b85875aad4cd7b63bf9100a65f2139"><td class="memTemplParams" colspan="2">template&lt;typename... TValue&gt; </td></tr>
<tr class="memitem:gac0b85875aad4cd7b63bf9100a65f2139"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#gac0b85875aad4cd7b63bf9100a65f2139">jsonv::merge</a> (TValue &amp;&amp;... values)</td></tr>
<tr class="memdesc:gac0b85875aad4cd7b63bf9100a65f2139"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges all the provided <em>values</em> into a single <code>value</code>.  <a href="group__Algorithm.html#gac0b85875aad4cd7b63bf9100a65f2139">More...</a><br /></td></tr>
<tr class="separator:gac0b85875aad4cd7b63bf9100a65f2139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a834e2dc802950967a7e9ef921f8a6"><td class="memTemplParams" colspan="2">template&lt;typename... TValue&gt; </td></tr>
<tr class="memitem:gad2a834e2dc802950967a7e9ef921f8a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#gad2a834e2dc802950967a7e9ef921f8a6">jsonv::merge_recursive</a> (TValue &amp;&amp;... values)</td></tr>
<tr class="memdesc:gad2a834e2dc802950967a7e9ef921f8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges all the provided <em>values</em> into a single <code>value</code>.  <a href="group__Algorithm.html#gad2a834e2dc802950967a7e9ef921f8a6">More...</a><br /></td></tr>
<tr class="separator:gad2a834e2dc802950967a7e9ef921f8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996c1ddc2732999a8bcd5212403ce2a5"><td class="memItemLeft" align="right" valign="top"><a id="ga996c1ddc2732999a8bcd5212403ce2a5"></a>
<a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classjsonv_1_1validation__error.html#af242a7b1e1e2c281d006a16b871e15bf">validation_error::code</a> &amp;code)</td></tr>
<tr class="separator:ga996c1ddc2732999a8bcd5212403ce2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4073c6d09edda785ddc21f1b35c5bdf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga4073c6d09edda785ddc21f1b35c5bdf6">jsonv::validate</a> (const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;val)</td></tr>
<tr class="memdesc:ga4073c6d09edda785ddc21f1b35c5bdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the provided <em>val</em> is perfectly representable as a JSON string.  <a href="group__Algorithm.html#ga4073c6d09edda785ddc21f1b35c5bdf6">More...</a><br /></td></tr>
<tr class="separator:ga4073c6d09edda785ddc21f1b35c5bdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2e68ce801ca3c29f80f104dd12c99d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga9e2e68ce801ca3c29f80f104dd12c99d">jsonv::value::map</a> (const std::function&lt; <a class="el" href="classjsonv_1_1value.html">value</a>(const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;)&gt; &amp;func) const &amp;</td></tr>
<tr class="memdesc:ga9e2e68ce801ca3c29f80f104dd12c99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a function over the values of this instance.  <a href="#ga9e2e68ce801ca3c29f80f104dd12c99d">More...</a><br /></td></tr>
<tr class="separator:ga9e2e68ce801ca3c29f80f104dd12c99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c7b3b2525144b37b24593db0f8d5a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga90c7b3b2525144b37b24593db0f8d5a9">jsonv::value::map</a> (const std::function&lt; <a class="el" href="classjsonv_1_1value.html">value</a>(<a class="el" href="classjsonv_1_1value.html">value</a>)&gt; &amp;func) &amp;&amp;</td></tr>
<tr class="memdesc:ga90c7b3b2525144b37b24593db0f8d5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a function over the values of this instance.  <a href="#ga90c7b3b2525144b37b24593db0f8d5a9">More...</a><br /></td></tr>
<tr class="separator:ga90c7b3b2525144b37b24593db0f8d5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A collection of useful free functions a la <code></code> &lt;algorithm&gt;. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structjsonv_1_1diff__result" id="structjsonv_1_1diff__result"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structjsonv_1_1diff__result">&#9670;&nbsp;</a></span>jsonv::diff_result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct jsonv::diff_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The results of the <code>diff</code> operation. </p>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00194">194</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="af1285a35bafce2c3e6943e8a6204f28f"></a><a class="el" href="classjsonv_1_1value.html">value</a></td>
<td class="fieldname">
left</td>
<td class="fielddoc">
Elements that were unique to the left hand side of the diff. </td></tr>
<tr><td class="fieldtype">
<a id="aea2653c65f11342d8fcfae4e4a8ac9d3"></a><a class="el" href="classjsonv_1_1value.html">value</a></td>
<td class="fieldname">
right</td>
<td class="fielddoc">
Elements that were unique to the right hand side of the diff. </td></tr>
<tr><td class="fieldtype">
<a id="a9b97bd901a23e479ed482ed56184f86a"></a><a class="el" href="classjsonv_1_1value.html">value</a></td>
<td class="fieldname">
same</td>
<td class="fielddoc">
Elements that were the same between the two halves of the diff. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga18053a6a38a0ddd3739a9b253e6f8301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18053a6a38a0ddd3739a9b253e6f8301">&#9670;&nbsp;</a></span>compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCompareTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int jsonv::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TCompareTraits &amp;&#160;</td>
          <td class="paramname"><em>traits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the values <em>a</em> and <em>b</em> using the comparison <em>traits</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCompareTraits</td><td>A type which should be compatible with the public signatures on the <code><a class="el" href="structjsonv_1_1compare__traits.html" title="Traits describing how to perform various aspects of comparison. ">compare_traits</a></code> class. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00124">124</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="gae72c162e414d753ba60c1e84b49ff2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae72c162e414d753ba60c1e84b49ff2ab">&#9670;&nbsp;</a></span>compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> int jsonv::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the values <em>a</em> and <em>b</em> with strict comparison traits. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classjsonv_1_1value.html#a50a89be9c59fdad1d3bed40610e1750d" title="Used to build a strict-ordering of JSON values. ">value::compare</a> </dd>
<dd>
compare_icase </dd></dl>

</div>
</div>
<a id="ga74b55f49e5cab8746e5304c132ae1e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74b55f49e5cab8746e5304c132ae1e87">&#9670;&nbsp;</a></span>compare_icase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> int jsonv::compare_icase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the values <em>a</em> and <em>b</em>, but use case-insensitive matching on <code>kind::string</code> values. </p>
<p>This does <em>not</em> use case-insensitive matching on the keys of objects!</p>
<dl class="section see"><dt>See also</dt><dd>compare </dd></dl>

</div>
</div>
<a id="ga2480514da0048b025804fd95635dbc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2480514da0048b025804fd95635dbc79">&#9670;&nbsp;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> <a class="el" href="group__Algorithm.html#structjsonv_1_1diff__result">diff_result</a> jsonv::diff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the differences and similarities between the structures of <em>left</em> and <em>right</em>. </p>
<p>If <em>left</em> and <em>right</em> have a different <code>kind</code> (and the kind difference is not <code>kind::integer</code> and <code>kind::decimal</code>), <em>left</em> and <em>right</em> will be placed directly in the result. If they have the same <code>kind</code> and it is scalar, the values get a direct comparison. If they are the same, the result is moved to <code><a class="el" href="group__Algorithm.html#a9b97bd901a23e479ed482ed56184f86a" title="Elements that were the same between the two halves of the diff. ">diff_result::same</a></code>. If they are different, <em>left</em> and <em>right</em> are moved to <code><a class="el" href="group__Algorithm.html#af1285a35bafce2c3e6943e8a6204f28f" title="Elements that were unique to the left hand side of the diff. ">diff_result::left</a></code> and <code><a class="el" href="group__Algorithm.html#aea2653c65f11342d8fcfae4e4a8ac9d3" title="Elements that were unique to the right hand side of the diff. ">diff_result::right</a></code>, respectively. For <code>kind::array</code> and <code>kind::object</code>, the <code>value</code> elements are compared recursively. </p>

</div>
</div>
<a id="ga6f0abfde4a15bb3d727727d17e055d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f0abfde4a15bb3d727727d17e055d4d">&#9670;&nbsp;</a></span>map() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> <a class="el" href="classjsonv_1_1value.html">value</a> jsonv::map </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classjsonv_1_1value.html">value</a>(const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a function over the values in the <em>input</em>. </p>
<p>The behavior of this function is different, depending on the <code>kind</code> of <em>input</em>. For scalar kinds (<code>kind::integer</code>, <code>kind::null</code>, etc), <em>func</em> is called once with the value. If <em>input</em> is <code>kind::array</code>, <code>func</code> is called for every value in the array and the output will be an array with each element transformed by <em>func</em>. If <em>input</em> is <code>kind::object</code>, the result will be an object with each key transformed by <em>func</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to apply to the element or elements of <em>input</em>. </td></tr>
    <tr><td class="paramname">input</td><td>The value to transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga20a92faf8b28a6ec0ea0360cdf475f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20a92faf8b28a6ec0ea0360cdf475f43">&#9670;&nbsp;</a></span>map() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> <a class="el" href="classjsonv_1_1value.html">value</a> jsonv::map </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classjsonv_1_1value.html">value</a>(<a class="el" href="classjsonv_1_1value.html">value</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classjsonv_1_1value.html">value</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a function over the values in the <em>input</em>. </p>
<p>The behavior of this function is different, depending on the <code>kind</code> of <em>input</em>. For scalar kinds (<code>kind::integer</code>, <code>kind::null</code>, etc), <em>func</em> is called once with the value. If <em>input</em> is <code>kind::array</code>, <code>func</code> is called for every value in the array and the output will be an array with each element transformed by <em>func</em>. If <em>input</em> is <code>kind::object</code>, the result will be an object with each key transformed by <em>func</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to apply to the element or elements of <em>input</em>. </td></tr>
    <tr><td class="paramname">input</td><td>The value to transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This version of <code>map</code> provides only a basic exception-safety guarantee. If an exception is thrown while transforming a non-scalar <code>kind</code>, there is no rollback action, so <em>input</em> is left in a usable, but <em>unpredictable</em> state. If you need a strong exception guarantee, use the version of <code>map</code> that takes a constant reference to a <code>value</code>. </dd></dl>

</div>
</div>
<a id="ga9e2e68ce801ca3c29f80f104dd12c99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e2e68ce801ca3c29f80f104dd12c99d">&#9670;&nbsp;</a></span>map() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjsonv_1_1value.html">value</a> jsonv::value::map </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classjsonv_1_1value.html">value</a>(const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a function over the values of this instance. </p>
<p>The behavior of this function is different, depending on the <code>kind</code>. For scalar kinds (<code>kind::integer</code>, <code>kind::null</code>, etc), <em>func</em> is called once with the value. If this is <code>kind::array</code>, <code>func</code> is called for every value in the array and the output will be an array with each element transformed by <em>func</em>. If this is <code>kind::object</code>, the result will be an object with each key transformed by <em>func</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to apply to the element or elements of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90c7b3b2525144b37b24593db0f8d5a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90c7b3b2525144b37b24593db0f8d5a9">&#9670;&nbsp;</a></span>map() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjsonv_1_1value.html">value</a> jsonv::value::map </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classjsonv_1_1value.html">value</a>(<a class="el" href="classjsonv_1_1value.html">value</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a function over the values of this instance. </p>
<p>The behavior of this function is different, depending on the <code>kind</code>. For scalar kinds (<code>kind::integer</code>, <code>kind::null</code>, etc), <em>func</em> is called once with the value. If this is <code>kind::array</code>, <code>func</code> is called for every value in the array and the output will be an array with each element transformed by <em>func</em>. If this is <code>kind::object</code>, the result will be an object with each key transformed by <em>func</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to apply to the element or elements of this instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This version of <code>map</code> provides only a basic exception-safety guarantee. If an exception is thrown while transforming a non-scalar <code>kind</code>, there is no rollback action, so <code>this</code> is left in a usable, but <em>unpredictable</em> state. If you need a strong exception guarantee, use the constant reference version of <code>map</code>. </dd></dl>

</div>
</div>
<a id="gac0b85875aad4cd7b63bf9100a65f2139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0b85875aad4cd7b63bf9100a65f2139">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TValue&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjsonv_1_1value.html">value</a> jsonv::merge </td>
          <td>(</td>
          <td class="paramtype">TValue &amp;&amp;...&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges all the provided <em>values</em> into a single <code>value</code>. </p>
<p>If there are any key or type conflicts, an exception will be thrown. </p>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00399">399</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="ga5f3d51f2832841e7c90ba1eb9b9b93a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f3d51f2832841e7c90ba1eb9b9b93a1">&#9670;&nbsp;</a></span>merge_explicit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> <a class="el" href="classjsonv_1_1value.html">value</a> jsonv::merge_explicit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1merge__rules.html">merge_rules</a> &amp;&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classjsonv_1_1path.html">path</a>&#160;</td>
          <td class="paramname"><em>current_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classjsonv_1_1value.html">value</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two <code>values</code>, <em>a</em> and <em>b</em> into a single <code>value</code>. </p>
<p>The merging follows a few simple rules:</p>
<ul>
<li>If <em><a class="el" href="group__Value.html#ga3721c2ed2f380809f2fc3b03a6f6fa53" title="Describes the kind of data a value holds. ">a.kind()</a></em> != <em><a class="el" href="group__Value.html#ga3721c2ed2f380809f2fc3b03a6f6fa53" title="Describes the kind of data a value holds. ">b.kind()</a></em> and they are not <code>kind::integer</code> and <code>kind::decimal</code>, call <em>on_type_conflict</em> and return the result.</li>
<li>Otherwise, branch based on the (shared) type:<ul>
<li><code>kind::object</code> - Return a new object with all the values from <em>a</em> and <em>b</em> for the keys which are unique per object. For the keys which are shared, the value is the result of <em>on_same_key</em>.</li>
<li><code>kind::array</code> - Return a new array with the values of <em>b</em> appended to <em>a</em>.</li>
<li><code>kind::string</code> - Return a new string with <em>b</em> appended to <em>a</em>.</li>
<li><code>kind::boolean</code> - Return <code>a.as_boolean() || b.as_boolean()</code></li>
<li><code>kind::integer</code> - If <b>is</b> <code>kind::integer</code>, return <code>a + b</code> as an integer; otherwise, return it as a decimal.</li>
<li><code>kind::decimal</code> - Return <code>a + b</code> as a decimal.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rules</td><td>are the rules to merge with (see <code><a class="el" href="classjsonv_1_1merge__rules.html" title="This class is used in merge_explicit for defining what the function should do in the cases of conflic...">merge_rules</a></code>). </td></tr>
    <tr><td class="paramname">current_path</td><td>The current <code>path</code> into the <code>value</code> that we are merging. This can be used to give more useful error information if we are merging recursively. </td></tr>
    <tr><td class="paramname">a</td><td>is a <code>value</code> to merge. </td></tr>
    <tr><td class="paramname">b</td><td>is a <code>value</code> to merge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad2a834e2dc802950967a7e9ef921f8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2a834e2dc802950967a7e9ef921f8a6">&#9670;&nbsp;</a></span>merge_recursive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TValue&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classjsonv_1_1value.html">value</a> jsonv::merge_recursive </td>
          <td>(</td>
          <td class="paramtype">TValue &amp;&amp;...&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges all the provided <em>values</em> into a single <code>value</code>. </p>
<p>If there are any keys which are shared, their values are also merged. </p>

<p class="definition">Definition at line <a class="el" href="algorithm_8hpp_source.html#l00411">411</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a id="gaf74e9854143e94b2b014efe15eb63fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf74e9854143e94b2b014efe15eb63fdf">&#9670;&nbsp;</a></span>traverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void jsonv::traverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classjsonv_1_1path.html">path</a> &amp;, const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1path.html">path</a> &amp;&#160;</td>
          <td class="paramname"><em>base_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leafs_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively walk the provided <em>tree</em> and call <em>func</em> for each item in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The JSON value to traverse. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call for each element in the tree. </td></tr>
    <tr><td class="paramname">base_path</td><td>The path to prepend to each output path to <em>func</em>. This can be useful if beginning traversal from inside of some JSON structure. </td></tr>
    <tr><td class="paramname">leafs_only</td><td>If true, call <em>func</em> only when the current path is a "leaf" value (<code>string</code>, <code>integer</code>, <code>decimal</code>, <code>boolean</code>, or <code>null</code> <em>or</em> an empty <code>array</code> or <code>object</code>); if false, call <em>func</em> for all entries in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc870c7f69dc8731b6a97afa97df43cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc870c7f69dc8731b6a97afa97df43cc">&#9670;&nbsp;</a></span>traverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void jsonv::traverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="classjsonv_1_1path.html">path</a> &amp;, const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leafs_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively walk the provided <em>tree</em> and call <em>func</em> for each item in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The JSON value to traverse. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call for each element in the tree. </td></tr>
    <tr><td class="paramname">leafs_only</td><td>If true, call <em>func</em> only when the current path is a "leaf" value (<code>string</code>, <code>integer</code>, <code>decimal</code>, <code>boolean</code>, or <code>null</code> <em>or</em> an empty <code>array</code> or <code>object</code>); if false, call <em>func</em> for all entries in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4073c6d09edda785ddc21f1b35c5bdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4073c6d09edda785ddc21f1b35c5bdf6">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void jsonv::validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the provided <em>val</em> is perfectly representable as a JSON string. </p>
<p>The JSON specification does not have support for things like non-finite floating-point numbers (<code>NaN</code> and <code>infinity</code>). This means <code>value</code> defined with these values will get serialized as <code>null</code>. This constitutes a loss of information, but not acting this way would lead to the encoder outputting invalid JSON text, which is completely unacceptable. Use this funciton to check that there will be no information loss when encoding.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsonv_1_1validation__error.html" title="Error thrown when an unrepresentable value is encountered in a JSON AST. ">validation_error</a></td><td>if <em>val</em> contains an unrepresentable value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
