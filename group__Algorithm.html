<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>JSON Voorhees: Algorithm</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://www.mathjax.org/mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">JSON Voorhees
   </div>
   <div id="projectbrief">Killer JSON for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__Algorithm.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithm</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of useful free functions a la <code></code> &lt;algorithm&gt;.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsonv_1_1compare__traits.html">jsonv::compare_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits describing how to perform various aspects of comparison.  <a href="structjsonv_1_1compare__traits.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structjsonv_1_1diff__result"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#structjsonv_1_1diff__result">jsonv::diff_result</a></td></tr>
<tr class="memdesc:structjsonv_1_1diff__result"><td class="mdescLeft">&#160;</td><td class="mdescRight">The results of the <code>diff</code> operation.  <a href="group__Algorithm.html#structjsonv_1_1diff__result">More...</a><br/></td></tr>
<tr class="separator:structjsonv_1_1diff__result"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsonv_1_1merge__rules.html">jsonv::merge_rules</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used in <code>merge_explicit</code> for defining what the function should do in the cases of conflicts.  <a href="classjsonv_1_1merge__rules.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsonv_1_1dynamic__merge__rules.html">jsonv::dynamic_merge_rules</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An implementation of <code><a class="el" href="classjsonv_1_1merge__rules.html" title="This class is used in merge_explicit for defining what the function should do in the cases of conflic...">merge_rules</a></code> that allows you to bind whatever functions you want to resolve conflicts.  <a href="classjsonv_1_1dynamic__merge__rules.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsonv_1_1throwing__merge__rules.html">jsonv::throwing_merge_rules</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These rules throw an exception on all conflicts.  <a href="classjsonv_1_1throwing__merge__rules.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsonv_1_1recursive__merge__rules.html">jsonv::recursive_merge_rules</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">These rules will recursively merge everything they can and coerce all values.  <a href="classjsonv_1_1recursive__merge__rules.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjsonv_1_1validation__error.html">jsonv::validation_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error thrown when an unrepresentable value is encountered in a JSON AST.  <a href="classjsonv_1_1validation__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsonv_1_1value__compare.html">jsonv::value_compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares a <code>value</code> to another using the standard-issue <code><a class="el" href="classjsonv_1_1value.html#a05f2fca552d114e678040be40c8cbc06" title="Used to build a strict-ordering of JSON values. ">value::compare</a></code> function.  <a href="structjsonv_1_1value__compare.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsonv_1_1value__compare__icase.html">jsonv::value_compare_icase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values, ignoring the case for any <code>value</code> with <code>kind::string</code>.  <a href="structjsonv_1_1value__compare__icase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structjsonv_1_1basic__value__binary__predicate.html">jsonv::basic_value_binary_predicate&lt; FCompare, FResult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6b17f22c37048a7a33470a9eec597909"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b17f22c37048a7a33470a9eec597909"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_equal_to</b> = basic_value_binary_predicate&lt; value_compare, std::equal_to&lt; int &gt;&gt;</td></tr>
<tr class="separator:ga6b17f22c37048a7a33470a9eec597909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac96410268b5f2341076ae0e17dc766eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac96410268b5f2341076ae0e17dc766eb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_equal_to_icase</b> = basic_value_binary_predicate&lt; value_compare_icase, std::equal_to&lt; int &gt;&gt;</td></tr>
<tr class="separator:gac96410268b5f2341076ae0e17dc766eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga360dbf67b6b3b55c910512447ef554c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga360dbf67b6b3b55c910512447ef554c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_not_equal_to</b> = basic_value_binary_predicate&lt; value_compare, std::not_equal_to&lt; int &gt;&gt;</td></tr>
<tr class="separator:ga360dbf67b6b3b55c910512447ef554c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13befc2e2be8e25304027acb802f9d82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga13befc2e2be8e25304027acb802f9d82"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_not_equal_to_icase</b> = basic_value_binary_predicate&lt; value_compare_icase, std::not_equal_to&lt; int &gt;&gt;</td></tr>
<tr class="separator:ga13befc2e2be8e25304027acb802f9d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga630826cff35b44ff716cc872012ca513"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga630826cff35b44ff716cc872012ca513"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_less</b> = basic_value_binary_predicate&lt; value_compare, std::less&lt; int &gt;&gt;</td></tr>
<tr class="separator:ga630826cff35b44ff716cc872012ca513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49ad5b953da45f2821dd28de3eb64b47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga49ad5b953da45f2821dd28de3eb64b47"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_less_icase</b> = basic_value_binary_predicate&lt; value_compare_icase, std::less&lt; int &gt;&gt;</td></tr>
<tr class="separator:ga49ad5b953da45f2821dd28de3eb64b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59b5fe5378649a29fc15be50cd109f5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga59b5fe5378649a29fc15be50cd109f5b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_less_equal</b> = basic_value_binary_predicate&lt; value_compare, std::less_equal&lt; int &gt;&gt;</td></tr>
<tr class="separator:ga59b5fe5378649a29fc15be50cd109f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc138b68b32948f21d87303247b10f28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc138b68b32948f21d87303247b10f28"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_less_equal_icase</b> = basic_value_binary_predicate&lt; value_compare_icase, std::less_equal&lt; int &gt;&gt;</td></tr>
<tr class="separator:gacc138b68b32948f21d87303247b10f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga948e515c77534bccf142b247dc7ea9a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga948e515c77534bccf142b247dc7ea9a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_greater</b> = basic_value_binary_predicate&lt; value_compare, std::greater&lt; int &gt;&gt;</td></tr>
<tr class="separator:ga948e515c77534bccf142b247dc7ea9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga941838a981fe67cf0ebf690093fea638"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga941838a981fe67cf0ebf690093fea638"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_greater_icase</b> = basic_value_binary_predicate&lt; value_compare_icase, std::greater&lt; int &gt;&gt;</td></tr>
<tr class="separator:ga941838a981fe67cf0ebf690093fea638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1a0de21a4fa7e0900d7ce68a8c955cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf1a0de21a4fa7e0900d7ce68a8c955cd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_greater_equal</b> = basic_value_binary_predicate&lt; value_compare, std::greater_equal&lt; int &gt;&gt;</td></tr>
<tr class="separator:gaf1a0de21a4fa7e0900d7ce68a8c955cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0e6d4d089cb05708ec58a0c16a9027"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed0e6d4d089cb05708ec58a0c16a9027"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::value_greater_equal_icase</b> = basic_value_binary_predicate&lt; value_compare_icase, std::greater_equal&lt; int &gt;&gt;</td></tr>
<tr class="separator:gaed0e6d4d089cb05708ec58a0c16a9027"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga18053a6a38a0ddd3739a9b253e6f8301"><td class="memTemplParams" colspan="2">template&lt;typename TCompareTraits &gt; </td></tr>
<tr class="memitem:ga18053a6a38a0ddd3739a9b253e6f8301"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga18053a6a38a0ddd3739a9b253e6f8301">jsonv::compare</a> (const value &amp;a, const value &amp;b, const TCompareTraits &amp;traits)</td></tr>
<tr class="memdesc:ga18053a6a38a0ddd3739a9b253e6f8301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values <em>a</em> and <em>b</em> using the comparison <em>traits</em>.  <a href="#ga18053a6a38a0ddd3739a9b253e6f8301">More...</a><br/></td></tr>
<tr class="separator:ga18053a6a38a0ddd3739a9b253e6f8301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae72c162e414d753ba60c1e84b49ff2ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#gae72c162e414d753ba60c1e84b49ff2ab">jsonv::compare</a> (const value &amp;a, const value &amp;b)</td></tr>
<tr class="memdesc:gae72c162e414d753ba60c1e84b49ff2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values <em>a</em> and <em>b</em> with strict comparison traits.  <a href="#gae72c162e414d753ba60c1e84b49ff2ab">More...</a><br/></td></tr>
<tr class="separator:gae72c162e414d753ba60c1e84b49ff2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b55f49e5cab8746e5304c132ae1e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga74b55f49e5cab8746e5304c132ae1e87">jsonv::compare_icase</a> (const value &amp;a, const value &amp;b)</td></tr>
<tr class="memdesc:ga74b55f49e5cab8746e5304c132ae1e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare the values <em>a</em> and <em>b</em>, but use case-insensitive matching on <code>kind::string</code> values.  <a href="#ga74b55f49e5cab8746e5304c132ae1e87">More...</a><br/></td></tr>
<tr class="separator:ga74b55f49e5cab8746e5304c132ae1e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2480514da0048b025804fd95635dbc79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> diff_result&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga2480514da0048b025804fd95635dbc79">jsonv::diff</a> (value left, value right)</td></tr>
<tr class="memdesc:ga2480514da0048b025804fd95635dbc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the differences and similarities between the structures of <em>left</em> and <em>right</em>.  <a href="#ga2480514da0048b025804fd95635dbc79">More...</a><br/></td></tr>
<tr class="separator:ga2480514da0048b025804fd95635dbc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0abfde4a15bb3d727727d17e055d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga6f0abfde4a15bb3d727727d17e055d4d">jsonv::map</a> (const std::function&lt; value(const value &amp;)&gt; &amp;func, const value &amp;input)</td></tr>
<tr class="memdesc:ga6f0abfde4a15bb3d727727d17e055d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a function over the values in the <em>input</em>.  <a href="#ga6f0abfde4a15bb3d727727d17e055d4d">More...</a><br/></td></tr>
<tr class="separator:ga6f0abfde4a15bb3d727727d17e055d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a92faf8b28a6ec0ea0360cdf475f43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga20a92faf8b28a6ec0ea0360cdf475f43">jsonv::map</a> (const std::function&lt; value(value)&gt; &amp;func, value &amp;&amp;input)</td></tr>
<tr class="memdesc:ga20a92faf8b28a6ec0ea0360cdf475f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a function over the values in the <em>input</em>.  <a href="#ga20a92faf8b28a6ec0ea0360cdf475f43">More...</a><br/></td></tr>
<tr class="separator:ga20a92faf8b28a6ec0ea0360cdf475f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74e9854143e94b2b014efe15eb63fdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#gaf74e9854143e94b2b014efe15eb63fdf">jsonv::traverse</a> (const value &amp;tree, const std::function&lt; void(const path &amp;, const value &amp;)&gt; &amp;func, const path &amp;base_path, bool leafs_only=false)</td></tr>
<tr class="memdesc:gaf74e9854143e94b2b014efe15eb63fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively walk the provided <em>tree</em> and call <em>func</em> for each item in the tree.  <a href="#gaf74e9854143e94b2b014efe15eb63fdf">More...</a><br/></td></tr>
<tr class="separator:gaf74e9854143e94b2b014efe15eb63fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc870c7f69dc8731b6a97afa97df43cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#gacc870c7f69dc8731b6a97afa97df43cc">jsonv::traverse</a> (const value &amp;tree, const std::function&lt; void(const path &amp;, const value &amp;)&gt; &amp;func, bool leafs_only=false)</td></tr>
<tr class="memdesc:gacc870c7f69dc8731b6a97afa97df43cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively walk the provided <em>tree</em> and call <em>func</em> for each item in the tree.  <a href="#gacc870c7f69dc8731b6a97afa97df43cc">More...</a><br/></td></tr>
<tr class="separator:gacc870c7f69dc8731b6a97afa97df43cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3d51f2832841e7c90ba1eb9b9b93a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga5f3d51f2832841e7c90ba1eb9b9b93a1">jsonv::merge_explicit</a> (const merge_rules &amp;rules, path current_path, value a, value b)</td></tr>
<tr class="memdesc:ga5f3d51f2832841e7c90ba1eb9b9b93a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges two <code>values</code>, <em>a</em> and <em>b</em> into a single <code>value</code>.  <a href="#ga5f3d51f2832841e7c90ba1eb9b9b93a1">More...</a><br/></td></tr>
<tr class="separator:ga5f3d51f2832841e7c90ba1eb9b9b93a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga953ea8225a035f7dd1dbb88285f980d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga953ea8225a035f7dd1dbb88285f980d4"></a>
<a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> value&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::merge_explicit</b> (const merge_rules &amp;, const path &amp;, value a)</td></tr>
<tr class="separator:ga953ea8225a035f7dd1dbb88285f980d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77f008513377f09e7d66e046bef67747"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga77f008513377f09e7d66e046bef67747"></a>
<a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> value&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::merge_explicit</b> (const merge_rules &amp;, const path &amp;)</td></tr>
<tr class="separator:ga77f008513377f09e7d66e046bef67747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab37af0937ad26c2817106dc21446f104"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab37af0937ad26c2817106dc21446f104"></a>
template&lt;typename... TValue&gt; </td></tr>
<tr class="memitem:gab37af0937ad26c2817106dc21446f104"><td class="memTemplItemLeft" align="right" valign="top">value&#160;</td><td class="memTemplItemRight" valign="bottom"><b>jsonv::merge_explicit</b> (const merge_rules &amp;rules, path current_path, value a, value b, value c, TValue &amp;&amp;...rest)</td></tr>
<tr class="separator:gab37af0937ad26c2817106dc21446f104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7084b1883a32bab8378bd8aab6ae71f"><td class="memTemplParams" colspan="2">template&lt;typename... TValue&gt; </td></tr>
<tr class="memitem:gaf7084b1883a32bab8378bd8aab6ae71f"><td class="memTemplItemLeft" align="right" valign="top">value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#gaf7084b1883a32bab8378bd8aab6ae71f">jsonv::merge</a> (TValue &amp;&amp;...values)</td></tr>
<tr class="memdesc:gaf7084b1883a32bab8378bd8aab6ae71f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges all the provided <em>values</em> into a single <code>value</code>.  <a href="#gaf7084b1883a32bab8378bd8aab6ae71f">More...</a><br/></td></tr>
<tr class="separator:gaf7084b1883a32bab8378bd8aab6ae71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbfed07c06da7ed1b28e64907aefea42"><td class="memTemplParams" colspan="2">template&lt;typename... TValue&gt; </td></tr>
<tr class="memitem:gafbfed07c06da7ed1b28e64907aefea42"><td class="memTemplItemLeft" align="right" valign="top">value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#gafbfed07c06da7ed1b28e64907aefea42">jsonv::merge_recursive</a> (TValue &amp;&amp;...values)</td></tr>
<tr class="memdesc:gafbfed07c06da7ed1b28e64907aefea42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges all the provided <em>values</em> into a single <code>value</code>.  <a href="#gafbfed07c06da7ed1b28e64907aefea42">More...</a><br/></td></tr>
<tr class="separator:gafbfed07c06da7ed1b28e64907aefea42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996c1ddc2732999a8bcd5212403ce2a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga996c1ddc2732999a8bcd5212403ce2a5"></a>
<a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>jsonv::operator&lt;&lt;</b> (std::ostream &amp;os, const validation_error::code &amp;code)</td></tr>
<tr class="separator:ga996c1ddc2732999a8bcd5212403ce2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4073c6d09edda785ddc21f1b35c5bdf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga4073c6d09edda785ddc21f1b35c5bdf6">jsonv::validate</a> (const value &amp;val)</td></tr>
<tr class="memdesc:ga4073c6d09edda785ddc21f1b35c5bdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the provided <em>val</em> is perfectly representable as a JSON string.  <a href="#ga4073c6d09edda785ddc21f1b35c5bdf6">More...</a><br/></td></tr>
<tr class="separator:ga4073c6d09edda785ddc21f1b35c5bdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e2e68ce801ca3c29f80f104dd12c99d"><td class="memItemLeft" align="right" valign="top">value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga9e2e68ce801ca3c29f80f104dd12c99d">jsonv::value::map</a> (const std::function&lt; value(const value &amp;)&gt; &amp;func) const &amp;</td></tr>
<tr class="memdesc:ga9e2e68ce801ca3c29f80f104dd12c99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a function over the values of this instance.  <a href="#ga9e2e68ce801ca3c29f80f104dd12c99d">More...</a><br/></td></tr>
<tr class="separator:ga9e2e68ce801ca3c29f80f104dd12c99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8801c26b1bb92cf42203aea4284f82be"><td class="memItemLeft" align="right" valign="top">value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Algorithm.html#ga8801c26b1bb92cf42203aea4284f82be">jsonv::value::map</a> (const std::function&lt; value(value)&gt; &amp;func)&amp;&amp;</td></tr>
<tr class="memdesc:ga8801c26b1bb92cf42203aea4284f82be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a function over the values of this instance.  <a href="#ga8801c26b1bb92cf42203aea4284f82be">More...</a><br/></td></tr>
<tr class="separator:ga8801c26b1bb92cf42203aea4284f82be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A collection of useful free functions a la <code></code> &lt;algorithm&gt;. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structjsonv_1_1diff__result" id="structjsonv_1_1diff__result"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct jsonv::diff_result</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>The results of the <code>diff</code> operation. </p>

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00194">194</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="af1285a35bafce2c3e6943e8a6204f28f"></a><a class="el" href="classjsonv_1_1value.html">value</a></td>
<td class="fieldname">
left</td>
<td class="fielddoc">
Elements that were unique to the left hand side of the diff. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="aea2653c65f11342d8fcfae4e4a8ac9d3"></a><a class="el" href="classjsonv_1_1value.html">value</a></td>
<td class="fieldname">
right</td>
<td class="fielddoc">
Elements that were unique to the right hand side of the diff. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a9b97bd901a23e479ed482ed56184f86a"></a><a class="el" href="classjsonv_1_1value.html">value</a></td>
<td class="fieldname">
same</td>
<td class="fielddoc">
Elements that were the same between the two halves of the diff. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga18053a6a38a0ddd3739a9b253e6f8301"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TCompareTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int jsonv::compare </td>
          <td>(</td>
          <td class="paramtype">const value &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TCompareTraits &amp;&#160;</td>
          <td class="paramname"><em>traits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the values <em>a</em> and <em>b</em> using the comparison <em>traits</em>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TCompareTraits</td><td>A type which should be compatible with the public signatures on the <code><a class="el" href="structjsonv_1_1compare__traits.html" title="Traits describing how to perform various aspects of comparison. ">compare_traits</a></code> class. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00124">124</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae72c162e414d753ba60c1e84b49ff2ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> int jsonv::compare </td>
          <td>(</td>
          <td class="paramtype">const value &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the values <em>a</em> and <em>b</em> with strict comparison traits. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classjsonv_1_1value.html#a05f2fca552d114e678040be40c8cbc06" title="Used to build a strict-ordering of JSON values. ">value::compare</a> </dd>
<dd>
compare_icase </dd></dl>

</div>
</div>
<a class="anchor" id="ga74b55f49e5cab8746e5304c132ae1e87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> int jsonv::compare_icase </td>
          <td>(</td>
          <td class="paramtype">const value &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare the values <em>a</em> and <em>b</em>, but use case-insensitive matching on <code>kind::string</code> values. </p>
<p>This does <em>not</em> use case-insensitive matching on the keys of objects!</p>
<dl class="section see"><dt>See Also</dt><dd>compare </dd></dl>

</div>
</div>
<a class="anchor" id="ga2480514da0048b025804fd95635dbc79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> diff_result jsonv::diff </td>
          <td>(</td>
          <td class="paramtype">value&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the differences and similarities between the structures of <em>left</em> and <em>right</em>. </p>
<p>If <em>left</em> and <em>right</em> have a different <code>kind</code> (and the kind difference is not <code>kind::integer</code> and <code>kind::decimal</code>), <em>left</em> and <em>right</em> will be placed directly in the result. If they have the same <code>kind</code> and it is scalar, the values get a direct comparison. If they are the same, the result is moved to <code><a class="el" href="group__Algorithm.html#a9b97bd901a23e479ed482ed56184f86a" title="Elements that were the same between the two halves of the diff. ">diff_result::same</a></code>. If they are different, <em>left</em> and <em>right</em> are moved to <code><a class="el" href="group__Algorithm.html#af1285a35bafce2c3e6943e8a6204f28f" title="Elements that were unique to the left hand side of the diff. ">diff_result::left</a></code> and <code><a class="el" href="group__Algorithm.html#aea2653c65f11342d8fcfae4e4a8ac9d3" title="Elements that were unique to the right hand side of the diff. ">diff_result::right</a></code>, respectively. For <code>kind::array</code> and <code>kind::object</code>, the <code>value</code> elements are compared recursively. </p>

</div>
</div>
<a class="anchor" id="ga6f0abfde4a15bb3d727727d17e055d4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> value jsonv::map </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; value(const value &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value &amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a function over the values in the <em>input</em>. </p>
<p>The behavior of this function is different, depending on the <code>kind</code> of <em>input</em>. For scalar kinds (<code>kind::integer</code>, <code>kind::null</code>, etc), <em>func</em> is called once with the value. If <em>input</em> is <code>kind::array</code>, <code>func</code> is called for every value in the array and the output will be an array with each element transformed by <em>func</em>. If <em>input</em> is <code>kind::object</code>, the result will be an object with each key transformed by <em>func</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to apply to the element or elements of <em>input</em>. </td></tr>
    <tr><td class="paramname">input</td><td>The value to transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga20a92faf8b28a6ec0ea0360cdf475f43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> value jsonv::map </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; value(value)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value &amp;&amp;&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a function over the values in the <em>input</em>. </p>
<p>The behavior of this function is different, depending on the <code>kind</code> of <em>input</em>. For scalar kinds (<code>kind::integer</code>, <code>kind::null</code>, etc), <em>func</em> is called once with the value. If <em>input</em> is <code>kind::array</code>, <code>func</code> is called for every value in the array and the output will be an array with each element transformed by <em>func</em>. If <em>input</em> is <code>kind::object</code>, the result will be an object with each key transformed by <em>func</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to apply to the element or elements of <em>input</em>. </td></tr>
    <tr><td class="paramname">input</td><td>The value to transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This version of <code>map</code> provides only a basic exception-safety guarantee. If an exception is thrown while transforming a non-scalar <code>kind</code>, there is no rollback action, so <em>input</em> is left in a usable, but <em>unpredictable</em> state. If you need a strong exception guarantee, use the version of <code>map</code> that takes a constant reference to a <code>value</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e2e68ce801ca3c29f80f104dd12c99d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">value jsonv::value::map </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classjsonv_1_1value.html">value</a>(const <a class="el" href="classjsonv_1_1value.html">value</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a function over the values of this instance. </p>
<p>The behavior of this function is different, depending on the <code>kind</code>. For scalar kinds (<code>kind::integer</code>, <code>kind::null</code>, etc), <em>func</em> is called once with the value. If this is <code>kind::array</code>, <code>func</code> is called for every value in the array and the output will be an array with each element transformed by <em>func</em>. If this is <code>kind::object</code>, the result will be an object with each key transformed by <em>func</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to apply to the element or elements of this instance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8801c26b1bb92cf42203aea4284f82be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">value jsonv::value::map </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classjsonv_1_1value.html">value</a>(<a class="el" href="classjsonv_1_1value.html">value</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a function over the values of this instance. </p>
<p>The behavior of this function is different, depending on the <code>kind</code>. For scalar kinds (<code>kind::integer</code>, <code>kind::null</code>, etc), <em>func</em> is called once with the value. If this is <code>kind::array</code>, <code>func</code> is called for every value in the array and the output will be an array with each element transformed by <em>func</em>. If this is <code>kind::object</code>, the result will be an object with each key transformed by <em>func</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to apply to the element or elements of this instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This version of <code>map</code> provides only a basic exception-safety guarantee. If an exception is thrown while transforming a non-scalar <code>kind</code>, there is no rollback action, so <code>this</code> is left in a usable, but <em>unpredictable</em> state. If you need a strong exception guarantee, use the constant reference version of <code>map</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7084b1883a32bab8378bd8aab6ae71f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TValue&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value jsonv::merge </td>
          <td>(</td>
          <td class="paramtype">TValue &amp;&amp;...&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges all the provided <em>values</em> into a single <code>value</code>. </p>
<p>If there are any key or type conflicts, an exception will be thrown. </p>

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00399">399</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga5f3d51f2832841e7c90ba1eb9b9b93a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> value jsonv::merge_explicit </td>
          <td>(</td>
          <td class="paramtype">const merge_rules &amp;&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">path&#160;</td>
          <td class="paramname"><em>current_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges two <code>values</code>, <em>a</em> and <em>b</em> into a single <code>value</code>. </p>
<p>The merging follows a few simple rules:</p>
<ul>
<li>If <em><a class="el" href="group__Value.html#ga3721c2ed2f380809f2fc3b03a6f6fa53" title="Describes the kind of data a value holds. ">a.kind()</a></em> != <em><a class="el" href="group__Value.html#ga3721c2ed2f380809f2fc3b03a6f6fa53" title="Describes the kind of data a value holds. ">b.kind()</a></em> and they are not <code>kind::integer</code> and <code>kind::decimal</code>, call <em>on_type_conflict</em> and return the result.</li>
<li>Otherwise, branch based on the (shared) type:<ul>
<li><code>kind::object</code> - Return a new object with all the values from <em>a</em> and <em>b</em> for the keys which are unique per object. For the keys which are shared, the value is the result of <em>on_same_key</em>.</li>
<li><code>kind::array</code> - Return a new array with the values of <em>b</em> appended to <em>a</em>.</li>
<li><code>kind::string</code> - Return a new string with <em>b</em> appended to <em>a</em>.</li>
<li><code>kind::boolean</code> - Return <code>a.as_boolean() || b.as_boolean()</code></li>
<li><code>kind::integer</code> - If <b>is</b> <code>kind::integer</code>, return <code>a + b</code> as an integer; otherwise, return it as a decimal.</li>
<li><code>kind::decimal</code> - Return <code>a + b</code> as a decimal.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rules</td><td>are the rules to merge with (see <code><a class="el" href="classjsonv_1_1merge__rules.html" title="This class is used in merge_explicit for defining what the function should do in the cases of conflic...">merge_rules</a></code>). </td></tr>
    <tr><td class="paramname">current_path</td><td>The current <code>path</code> into the <code>value</code> that we are merging. This can be used to give more useful error information if we are merging recursively. </td></tr>
    <tr><td class="paramname">a</td><td>is a <code>value</code> to merge. </td></tr>
    <tr><td class="paramname">b</td><td>is a <code>value</code> to merge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafbfed07c06da7ed1b28e64907aefea42"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... TValue&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value jsonv::merge_recursive </td>
          <td>(</td>
          <td class="paramtype">TValue &amp;&amp;...&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges all the provided <em>values</em> into a single <code>value</code>. </p>
<p>If there are any keys which are shared, their values are also merged. </p>

<p>Definition at line <a class="el" href="algorithm_8hpp_source.html#l00411">411</a> of file <a class="el" href="algorithm_8hpp_source.html">algorithm.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaf74e9854143e94b2b014efe15eb63fdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void jsonv::traverse </td>
          <td>(</td>
          <td class="paramtype">const value &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const path &amp;, const value &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const path &amp;&#160;</td>
          <td class="paramname"><em>base_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leafs_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively walk the provided <em>tree</em> and call <em>func</em> for each item in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The JSON value to traverse. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call for each element in the tree. </td></tr>
    <tr><td class="paramname">base_path</td><td>The path to prepend to each output path to <em>func</em>. This can be useful if beginning traversal from inside of some JSON structure. </td></tr>
    <tr><td class="paramname">leafs_only</td><td>If true, call <em>func</em> only when the current path is a "leaf" value (<code>string</code>, <code>integer</code>, <code>decimal</code>, <code>boolean</code>, or <code>null</code> <em>or</em> an empty <code>array</code> or <code>object</code>); if false, call <em>func</em> for all entries in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gacc870c7f69dc8731b6a97afa97df43cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void jsonv::traverse </td>
          <td>(</td>
          <td class="paramtype">const value &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const path &amp;, const value &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leafs_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively walk the provided <em>tree</em> and call <em>func</em> for each item in the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The JSON value to traverse. </td></tr>
    <tr><td class="paramname">func</td><td>The function to call for each element in the tree. </td></tr>
    <tr><td class="paramname">leafs_only</td><td>If true, call <em>func</em> only when the current path is a "leaf" value (<code>string</code>, <code>integer</code>, <code>decimal</code>, <code>boolean</code>, or <code>null</code> <em>or</em> an empty <code>array</code> or <code>object</code>); if false, call <em>func</em> for all entries in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4073c6d09edda785ddc21f1b35c5bdf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8hpp.html#acd0703012bd724b356c177b7bc3d761d">JSONV_PUBLIC</a> void jsonv::validate </td>
          <td>(</td>
          <td class="paramtype">const value &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that the provided <em>val</em> is perfectly representable as a JSON string. </p>
<p>The JSON specification does not have support for things like non-finite floating-point numbers (<code>NaN</code> and <code>infinity</code>). This means <code>value</code> defined with these values will get serialized as <code>null</code>. This constitutes a loss of information, but not acting this way would lead to the encoder outputting invalid JSON text, which is completely unacceptable. Use this funciton to check that there will be no information loss when encoding.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classjsonv_1_1validation__error.html" title="Error thrown when an unrepresentable value is encountered in a JSON AST. ">validation_error</a></td><td>if <em>val</em> contains an unrepresentable value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
