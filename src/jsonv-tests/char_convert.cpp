/** \file
 *  
 *  Copyright (c) 2014 by Travis Gockel. All rights reserved.
 *
 *  This program is free software: you can redistribute it and/or modify it under the terms of the Apache License
 *  as published by the Apache Software Foundation, either version 2 of the License, or (at your option) any later
 *  version.
 *
 *  \author Travis Gockel (travis@gockelhut.com)
**/
#include "test.hpp"

#include <jsonv/char_convert.hpp>

using jsonv::detail::decode_error;

template <std::size_t N>
static std::string string_decode_static(const char (& data)[N])
{
    // Use N-1 for length to not include the '\0' at the end
    return jsonv::detail::string_decode(data, N-1);
}

TEST(string_decode_unchanged)
{
    ensure_eq("Hello!", string_decode_static("Hello!"));
}

TEST(string_decode_utf_one_char)
{
    ensure_eq("\xe2\x98\xa2", string_decode_static("\\u2622"));
}

TEST(string_decode_utf_char_starts)
{
    ensure_eq("\xe2\x98\xa2normal text", string_decode_static("\\u2622normal text"));
}

TEST(string_decode_utf_char_ends)
{
    ensure_eq("normal text\xe2\x98\xa2", string_decode_static("normal text\\u2622"));
}

TEST(string_decode_utf_char_bookends)
{
    ensure_eq("\xe2\x98\xa2normal text\xe2\x9d\xa4", string_decode_static("\\u2622normal text\\u2764"));
}

TEST(string_decode_utf_char_surrounded)
{
    ensure_eq("normal\xe2\x98\xa2text", string_decode_static("normal\\u2622text"));
}

TEST(string_decode_utf_many_chars)
{
    ensure_eq("\xe2\x9d\xa4 \xe2\x98\x80 \xe2\x98\x86 \xe2\x98\x82 \xe2\x98\xbb \xe2\x99\x9e \xe2\x98\xaf \xe2\x98\xad \xe2\x98\xa2 \xe2\x82\xac \xe2\x86\x92 \xe2\x98\x8e \xe2\x9d\x84 \xe2\x99\xab \xe2\x9c\x82 \xe2\x96\xb7 \xe2\x9c\x87 \xe2\x99\x8e \xe2\x87\xa7 \xe2\x98\xae \xe2\x99\xbb \xe2\x8c\x98 \xe2\x8c\x9b \xe2\x98\x98",
              string_decode_static("\\u2764 \\u2600 \\u2606 \\u2602 \\u263b \\u265e \\u262f \\u262d \\u2622 \\u20ac \\u2192 \\u260e \\u2744 \\u266b \\u2702 \\u25b7 \\u2707 \\u264e \\u21e7 \\u262e \\u267b \\u2318 \\u231b \\u2618"));
}

TEST(string_decode_unicode_surrogates_valid)
{
    // A bunch of surrogate pairs generated by Python
    ensure_eq("\xf0\x90\x80\x80", string_decode_static(R"(\ud800\udc00)"));
    ensure_eq("\xf0\x97\x9f\xa0", string_decode_static(R"(\ud81d\udfe0)"));
    ensure_eq("\xf2\xba\xbe\x85", string_decode_static(R"(\udaab\udf85)"));
    ensure_eq("\xf0\xba\xad\xbe", string_decode_static(R"(\ud8aa\udf7e)"));
    ensure_eq("\xf1\xbb\xb7\xb0", string_decode_static(R"(\ud9af\uddf0)"));
    ensure_eq("\xf0\xb7\xbc\xb4", string_decode_static(R"(\ud89f\udf34)"));
    ensure_eq("\xf0\x9c\xa9\xa3", string_decode_static(R"(\ud832\ude63)"));
    ensure_eq("\xf3\x81\xbd\xad", string_decode_static(R"(\udac7\udf6d)"));
    ensure_eq("\xf3\x97\xa6\xa0", string_decode_static(R"(\udb1e\udda0)"));
    ensure_eq("\xf4\x8a\x91\xbe", string_decode_static(R"(\udbe9\udc7e)"));
    ensure_eq("\xf2\xb5\xb4\xba", string_decode_static(R"(\uda97\udd3a)"));
    ensure_eq("\xf0\xb7\x9e\xb4", string_decode_static(R"(\ud89d\udfb4)"));
    ensure_eq("\xf3\xa8\x8e\x8c", string_decode_static(R"(\udb60\udf8c)"));
    ensure_eq("\xf2\x8b\x98\x85", string_decode_static(R"(\ud9ed\ude05)"));
    ensure_eq("\xf3\x99\xae\x9c", string_decode_static(R"(\udb26\udf9c)"));
    ensure_eq("\xf1\xaa\xa9\x96", string_decode_static(R"(\ud96a\ude56)"));
    ensure_eq("\xf1\xb4\x98\x8a", string_decode_static(R"(\ud991\ude0a)"));
    ensure_eq("\xf0\x94\xab\x97", string_decode_static(R"(\ud812\uded7)"));
    ensure_eq("\xf2\x80\xbf\xb8", string_decode_static(R"(\ud9c3\udff8)"));
    ensure_eq("\xf1\xb8\x8d\x8d", string_decode_static(R"(\ud9a0\udf4d)"));
    ensure_eq("\xf3\x95\x84\xaa", string_decode_static(R"(\udb14\udd2a)"));
    ensure_eq("\xf0\xab\xbf\x8b", string_decode_static(R"(\ud86f\udfcb)"));
    ensure_eq("\xf1\x99\x86\x82", string_decode_static(R"(\ud924\udd82)"));
    ensure_eq("\xf2\x8f\x87\xa0", string_decode_static(R"(\ud9fc\udde0)"));
    ensure_eq("\xf2\x85\x8b\x97", string_decode_static(R"(\ud9d4\uded7)"));
    ensure_eq("\xf2\xb6\xa5\xaa", string_decode_static(R"(\uda9a\udd6a)"));
    ensure_eq("\xf2\x9f\xb4\xa7", string_decode_static(R"(\uda3f\udd27)"));
    ensure_eq("\xf3\x91\x9b\x9f", string_decode_static(R"(\udb05\udedf)"));
    ensure_eq("\xf1\xab\xbb\x9c", string_decode_static(R"(\ud96f\udedc)"));
    ensure_eq("\xf3\xb5\xb3\xa9", string_decode_static(R"(\udb97\udce9)"));
    ensure_eq("\xf4\x82\x95\x93", string_decode_static(R"(\udbc9\udd53)"));
    ensure_eq("\xf1\xb1\xa9\xb5", string_decode_static(R"(\ud986\ude75)"));
    ensure_eq("\xf2\xad\x85\xbf", string_decode_static(R"(\uda74\udd7f)"));
    ensure_eq("\xf1\x8e\x8f\xa2", string_decode_static(R"(\ud8f8\udfe2)"));
    ensure_eq("\xf1\x9e\xba\x9a", string_decode_static(R"(\ud93b\ude9a)"));
    ensure_eq("\xf2\x90\xac\xb3", string_decode_static(R"(\uda02\udf33)"));
    ensure_eq("\xf3\x9d\xa7\x82", string_decode_static(R"(\udb36\uddc2)"));
    ensure_eq("\xf2\xa1\xab\xa6", string_decode_static(R"(\uda46\udee6)"));
    ensure_eq("\xf2\x94\x98\x97", string_decode_static(R"(\uda11\ude17)"));
    ensure_eq("\xf3\xa0\x87\xa2", string_decode_static(R"(\udb40\udde2)"));
    ensure_eq("\xf2\x9b\xa7\xb3", string_decode_static(R"(\uda2e\uddf3)"));
    ensure_eq("\xf2\xa7\xab\xaf", string_decode_static(R"(\uda5e\udeef)"));
    ensure_eq("\xf1\xb3\x90\xa1", string_decode_static(R"(\ud98d\udc21)"));
    ensure_eq("\xf2\xbb\x88\x81", string_decode_static(R"(\udaac\ude01)"));
    ensure_eq("\xf3\xab\x9e\xb6", string_decode_static(R"(\udb6d\udfb6)"));
    ensure_eq("\xf4\x8e\xb3\xa1", string_decode_static(R"(\udbfb\udce1)"));
    ensure_eq("\xf4\x8a\x95\x99", string_decode_static(R"(\udbe9\udd59)"));
    ensure_eq("\xf0\x99\xbe\xb9", string_decode_static(R"(\ud827\udfb9)"));
    ensure_eq("\xf0\xa6\x9c\x85", string_decode_static(R"(\ud859\udf05)"));
    ensure_eq("\xf1\x97\xb3\xbf", string_decode_static(R"(\ud91f\udcff)"));
    ensure_eq("\xf1\x9a\xbc\xbb", string_decode_static(R"(\ud92b\udf3b)"));
}

TEST(string_decode_unicode_surrogates_invalid_end_immediate)
{
    ensure_throws(decode_error, string_decode_static(R"(\ud92b)"));
}

TEST(string_decode_unicode_surrogates_invalid_non_numeric_following)
{
    ensure_throws(decode_error, string_decode_static(R"(\ud92b____i____)"));
    ensure_throws(decode_error, string_decode_static(R"(\ud92b,.//<<>>/)"));
    ensure_throws(decode_error, string_decode_static(R"(\ud92b??!!897123)"));
    ensure_throws(decode_error, string_decode_static(R"(\ud92b__)"));
}

TEST(string_decode_unicode_surrogates_invalid_incomplete_escapes)
{
    ensure_throws(decode_error, string_decode_static(R"(\ud92b\u)"));
    ensure_throws(decode_error, string_decode_static(R"(\ud92b\ud)"));
    ensure_throws(decode_error, string_decode_static(R"(\ud92b\udc)"));
    ensure_throws(decode_error, string_decode_static(R"(\ud92b\udcb)"));
}

TEST(string_decode_unicode_surrogates_invalid_non_hex)
{
    ensure_throws(std::range_error, string_decode_static(R"(\ud92b\uPIKA)"));
    ensure_throws(std::range_error, string_decode_static(R"(\ud92b\ucattle)"));
    ensure_throws(std::range_error, string_decode_static(R"(\ud92b\u_________)"));
    ensure_throws(std::range_error, string_decode_static(R"(\ud92b\ujust bogus)"));
}

TEST(string_decode_unicode_surrogates_invalid_not_low_follower)
{
    ensure_throws(decode_error, string_decode_static(R"(\ud92b\ucccc)"));
    ensure_throws(decode_error, string_decode_static(R"(\ud92b\ubeefy)"));
    ensure_throws(decode_error, string_decode_static(R"(\ud92b\ud800)"));
    ensure_throws(decode_error, string_decode_static(R"(\ud92b\udbff\udc00)"));
}